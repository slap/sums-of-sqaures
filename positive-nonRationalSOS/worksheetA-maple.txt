#######################################################################
# Example of a strictly positive polynomial that is a SOS over R 
# but not over Q
#######################################################################


#######################################################################
# Load "Rational SOS" procedures
#######################################################################
read("rationalSOS.mpl");
with(rationalSOS);

# Display tables of any size
interface(rtablesize=infinity);


#######################################################################
# Construction of the example
#######################################################################

#######################################################################
# 1) A polynomial of degree 4 in 4 variables with no rational 
#    decomposition. This example was constructed by J. Capco, 
#    S. Laplagne and C. Scheiderer.
#######################################################################

# We define a polynomial as the sum of three squares in an algebraic
# extension of degree 3 with generic coefficients.

mp := t^3-2; 
p1 := c1*t^2+b1*t+a1; 
p2 := c2*t^2+b2*t+a2; 
p3 := c3*t^2+b3*t+a3; 

fGeneric := p1^2+p2^2+p3^2; 
fGeneric := expand(fGeneric);

# We choose arbitrary parameters so that all terms in the resulting 
# expressions for a1 and a2 are multiples of x0, and the degree
# is reduced after cancellation.
b2 := -b1;  c2 := b2;  c1 := b2; 
b1 := x0; b3 := x1; a3 := x2; c3 := x3;

# We solve the coefficients a1 and a2 so that the polynomial is in Q,
f2 := NormalForm(fGeneric, [mp], plex(a1, a2, x0, x1, x2, x3, t)); 
f3 := collect(f2, t); 
lf := CoefficientList(f3, t); 
ss := solve({lf[2], lf[3]}, {a1, a2});

# We plug in the solutions found for a1 and a2 and compute the resulting polynomial
ssDen := denom(rhs(ss[1])); 
p1s := simplify(subs(ss, p1)*ssDen); 
p2s := simplify(subs(ss, p2)*ssDen); 
p3s := simplify(subs(ss, p3)*ssDen);

# We replace t by the root of X^3-2
p1ss := subs({t = RootOf(X^3-2)}, p1s); 
p2ss := subs({t = RootOf(X^3-2)}, p2s); 
p3ss := subs({t = RootOf(X^3-2)}, p3s); 

# We compute f and verify that it is has rational coefficients
f := p1ss^2 + p2ss^2 + p3ss^2;
f := simplify(f);

# We verify that there is no solution with x2 = 0
sols := solve({p1ss, p2ss, p3ss, x2});

# Computation of a quadratic form associated to a linear functional in
# the dual of the cone of SOS polynomials that vanishes at f
# with kernel of small dimension.

# We construct all monomials of degree 2 and 4
d := 2;
polVarsX := [x0,x1,x2,x3];
varSum := add(polVarsX[i], i = 1..nops(polVarsX)):
md := expand((varSum)^d):
cfs := coeffs(md, polVarsX, 'ctdX'):
print("Monomials of degree d: ", ctdX);
m2d := expand(varSum^(2*d)):
cfs := coeffs(m2d, polVarsX, 'ct2dX'):
print("Monomials of degree 2d: ", ct2dX);

# We construct the linear form that vanishes at all products piss * h
pListX := [p1ss, p2ss, p3ss]:
MX := [];
for j from 1 to nops(pListX) do
  for i from 1 to nops([ctdX]) do
    p1tX := expand(pListX[j] * ctdX[i]);
    vec := LinearAlgebra[Transpose](getCoeffs(p1tX, [ct2dX]));
    if (nops(MX)=0) then
      MX := <vec>;
    else
      MX := <MX,vec>;
    end if;
  end do:
end do:
rc := [Dimension(MX)];
nr := rc[1];
B:=Vector(nr):
sX:=LinearAlgebra[LinearSolve](MX,B):
varssX:=indets(sX);
nops(varssX);  # 8 indeterminates left to solve

# We define a generic polynomial of degree d with coefficientes q_i.
qIndX := [seq(q[i], i=1..nops([ctdX]))]:
psaX := add(q[i] * ctdX[i], i = 1..nops([ctdX]));

# The square of psaX and the coefficients
ps2X := expand(psaX*psaX):
aaX := getCoeffs(expand(ps2X), [ct2dX]):

# We compute the form and look for a PSD matrix using SEDUMI
ewX := LinearAlgebra[Transpose](sX) . aaX:
ooX := polyToMatrixVars(expand(ewX), qIndX):

# Numerical optimization using SEDUMI.
# Numerically, the matrix has kernel of dimension 6.
oEval := ooX[1]:
outA := numericSolverSubmatrixMaxRank(evalf(oEval), "eig"):
QEval := eval(oEval,Equate([op(outA[2])], outA[3][1..nops([op(outA[2])])])):
smallToZeroMatrix(evalf(QEval), 8);
print(eig(QEval));


# Based on the numerical solution, we compute exact values of the 
# unknowns to construct an exact PSD matrix.

# The values obtained by SEDUMI are: 
# t_1 = -0.0000, t_2 = -0.1996, t_3 = 0.1272, t_4 = 0.0000,
# t_5 =  0.4435, t_6 =  0.0724, t_7 = 0.0080, t_8 = 0.2442

## We fix some variables to 0
oEvalX := eval(ooX[1], {varssX[1] = 0, varssX[4] = 0,varssX[7] = 0}):

## We fix other variables with positive values
oEvalX := eval(oEvalX, {varssX[5] = 1,varssX[8] = 1, varssX[3] = 1/2}):

## We compute exact values for the remaining two variables.

# We observe that in the numerical solution, there are two singular
# principal matrices.
evalf(Determinant(QEval[5 .. 7, 5 .. 7]));
evalf(Determinant(QEval[2 .. 3, 2 .. 3]));

# We compute symbolically the values of the unknowns that make the matrices singular.
S_23 := solve(Determinant(oEvalX[2 .. 3, 2 .. 3]), indets(oEvalX[2 .. 3, 2 .. 3])):
S_23_1 := simplify(S_23[1]);

oX_567 := eval(oEvalX[5 .. 7, 5 .. 7], S_23_1):
S_567 := solve(Determinant(oX_567), indets(oX_567)):
S_567_2 := simplify(S_567[2]);

# We apply these substitutions (using simplified expressions equivalent to the results by Maple)
rA := RootOf(_Z^3-2):
rB := RootOf(_Z*rA^2-rA^2+_Z^2+1):
rC := -(1/2)*rA-(1/2)*rB:

oEvalX := eval(oEvalX, {varssX[2] = rC}):
oEvalX := eval(oEvalX, {varssX[6] = rB}):

# No indetermiantes in the resulting oEvalX
evalf(oEvalX);

# The matrix has kernel of rank 6 and it is positive semidefinite
evalf(Eigenvalues(oEvalX));

# The kernel of the resulting form
LX := NullSpace(oEvalX):
nops(LX);

# The polynoials in the kernel
LinearAlgebra[Transpose](simplify(LX[01]));
LinearAlgebra[Transpose](simplify(LX[02]));
LinearAlgebra[Transpose](simplify(LX[03]));
LinearAlgebra[Transpose](simplify(LX[04]));
LinearAlgebra[Transpose](simplify(LX[05]));
LinearAlgebra[Transpose](simplify(LX[06]));



#######################################################################
# 2) We add the second block from an example in the strictly 
#    positive border of (4,4) 
#######################################################################

# g is the sum of 4 squares
g1 := y0^2-y3^2;
g2 := y1^2-y3^2;
g3 := y2^2-y3^2;
g4 := -y0^2 - y0*y1 -y0*y2 + y0*y3 - y1*y2 + y1*y3 + y2*y3;
g  :=  g1^2 + g2^2 + g3^2 + g4^2;

# We look for a form in the y-monomials that vanishes in the g_i
d := 2;
polVarsY := [y0,y1,y2,y3];
varSumY := add(polVarsY[i], i = 1..nops(polVarsY));
mdY := expand((varSumY)^d); 
cfsY := coeffs(mdY, polVarsY, 'ctdY'); 
m2dY := expand(varSumY^(2*d)); 
cfsY := coeffs(m2dY, polVarsY, 'ct2dY'); 

# We compute all the restrictions to phi: A4 -> R given
# by the five polynomials. There are 20 restrictions for each polynomial

pListY := [g1, g2, g3, g4];
MY := []:
for j from 1 to nops(pListY) do
  for i from 1 to nops([ctdY]) do
    p1t := expand(pListY[j] * ctdY[i]);
    vec := LinearAlgebra[Transpose](getCoeffs(p1t, [ct2dY]));
    if (nops(MY)=0) then
      MY := <vec>;
    else
      MY := <MY,vec>;
    end if;
  end do:
end do:

# We solve the system using only these restrictions
rc := [Dimension(MY)];
nr := rc[1];
B:=Vector(nr):
s:=LinearAlgebra[LinearSolve](MY,B):
varssY:=indets(s);
nops(varssY);  # Onlt 1 indeterminate left to solve

# We give values to the unknowns so that the form is PSD
qIndY := [seq(qY[i], i = 1..nops([ctdY]))];
psaY := add(qIndY[i] * ctdY[i], i = 1..nops([ctdY])):
ps2Y := expand(psaY*psaY):
aaY := getCoeffs(expand(ps2Y), [ct2dY]):

# We compute the form and verify it is PSD
ewY := LinearAlgebra[Transpose](s) . aaY:
ooY := polyToMatrixVars(expand(ewY), qIndY):
ooMY := ooY[1]:

# We give value 1 to the only indeterminate
oEvalY := eval(ooMY, {varssY[1] = 1});

######################################################################
# 3) Finally, we add the two examples plus a third polynomial to 
# ensure that there are no real roots.
######################################################################

h := (- x2^2 + y2^2);
p := f + g1^2 + g2^2 + g3^2 + g4^2 + h^2:
expand(p);

# We construct a linear form in the dual of the SOS cone that
# vanishes in all the 9 polynomials such that the associated
# quadratic form has kernel of minimal rank.

d := 2;
polVarsXY := [x0, x1, x2, x3, y0, y1, y2, y3];
varSumXY := add(polVarsXY[i], i = 1..nops(polVarsXY));

# We use a block ordering for the monomials
mdXY := [x0^2, x0*x1, x0*x2, x0*x3, x1^2, x1*x2, x1*x3, x2^2, x2*x3, x3^2, y0^2, y0*y1, y0*y2, y0*y3, y1^2, y1*y2, y1*y3, y2^2, y2*y3, y3^2, x0*y0, x0*y1, x0*y2, x0*y3, x1*y0, x1*y1, x1*y2, x1*y3, x2*y0, x2*y1, x2*y2, x2*y3, x3*y0, x3*y1, x3*y2, x3*y3]:
ctdXY := op(mdXY):
print("Monomials of degree d: ", ctdXY);

m2dXY := expand(varSumXY^(2*d)):
cfs := coeffs(m2dXY, polVarsXY, 'ct2dXY'):
print("Monomials of degree 2d: ", ct2dXY);

# We compute all the restrictions to phi: A4 -> R given
# by the five polynomials. There are 20 restrictions for each polynomial

pList := [p1ss, p2ss, p3ss, g1, g2, g3, g4, h];
MXY := []:
for j from 1 to nops(pList) do
  for i from 1 to nops([ctdXY]) do
    p1t := expand(pList[j] * ctdXY[i]);
    vec := LinearAlgebra[Transpose](getCoeffs(p1t, [ct2dXY]));
    if (nops(MXY)=0) then
      MXY := <vec>;
    else
      MXY := <MXY,vec>;
    end if;
  end do:
end do:

# We solve the system using only these restrictions
rc := [Dimension(MXY)];
nr := rc[1];
B:=Vector(nr):
sXY:=LinearAlgebra[LinearSolve](MXY,B):
varssXY:=indets(sXY);
nops(varssXY);  # 70 indeterminates left to solve

# We give values to the unknowns so that the form is PSD
qIndXY := [seq(qXY[i], i = 1..nops([ctdXY]))]:
psaXY := add(qIndXY[i] * ctdXY[i], i = 1..nops([ctdXY])):
ps2XY := expand(psaXY*psaXY):
aaXY := getCoeffs(expand(ps2XY), [ct2dXY]):

# We compute the form and verify it is PSD
ewXY := LinearAlgebra[Transpose](sXY) . aaXY:
ooXY := polyToMatrixVars(expand(ewXY), qIndXY):
ooMXY := ooXY[1]:

# We copy Q_x and Q_y in Q_xy
s1 := solve(Equate(ooMXY[1..10, 1..10], oEvalX)):
oEvalXY := eval(ooMXY, {ooMXY[20,20] = 6}):
oEvalXY := eval(oEvalXY, s1):

# We replace all the remaining variables by 0
s2 := solve(Equate([op(indets(oEvalXY))], ZeroVector(nops(indets(oEvalXY))))):
oEvalXY := eval(oEvalXY, s2):

# We verify that the matrix is positive semidefinite and has kernel
# of rank 14.
evalf(Eigenvalues(oEvalXY));

# The kernel is generated by 14 polynomials
L := NullSpace(oEvalXY):
nops(L);

# The polynoials in the kernel
simplify(L[01]) . convert(mdXY, Vector);
simplify(L[02]) . convert(mdXY, Vector);
simplify(L[03]) . convert(mdXY, Vector);
simplify(L[04]) . convert(mdXY, Vector);
simplify(L[05]) . convert(mdXY, Vector);
simplify(L[06]) . convert(mdXY, Vector);
simplify(L[07]) . convert(mdXY, Vector);
simplify(L[08]) . convert(mdXY, Vector);
simplify(L[09]) . convert(mdXY, Vector);
simplify(L[10]) . convert(mdXY, Vector);
simplify(L[11]) . convert(mdXY, Vector);
simplify(L[12]) . convert(mdXY, Vector);
simplify(L[13]) . convert(mdXY, Vector);
simplify(L[14]) . convert(mdXY, Vector);

